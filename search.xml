<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Brute Ratel C4红队框架和EDR的猫鼠游戏</title>
    <url>/brute-ratel-c4-redteam-tools-analysis.html</url>
    <content><![CDATA[<p><strong>本篇文章为本人原创，首发于<a href="https://www.freebuf.com/articles/system/341336.html">freebuf</a></strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Brute Ratel C4是类似于Cobalt Strike的商业红队框架，每年的License收费为$2500，首个版本Brute Ratel C4 v0.2 (Prometheus)于2021年2月9日发布，截至发稿最新发布版本v1.1(Stoffel’s Escape)与2022年7月20日发布，相比与Cobalt Strike的知名度BRc4显然要低调的多，但是BRc4使用的技术和功能却丝毫不亚于CS，本次分析的样本使用的最终payload就是BRc4</p>
<span id="more"></span>

<h1 id="样本运行流程图"><a href="#样本运行流程图" class="headerlink" title="样本运行流程图"></a>样本运行流程图</h1><p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Y73JP0TF1reovJWVRQHK9wukHkKSLT2n/20220816liuchengtu.png"></p>
<h1 id="样本IOCs"><a href="#样本IOCs" class="headerlink" title="样本IOCs"></a>样本IOCs</h1><p>名称: Roshan_CV.iso<br>大小: 4839424 字节 (4726 KiB)<br>MD5: a7df3462a6dce565064cfe408557c4df<br>SHA1: 6b91bfc761fe958c8ac04dd403db284ccc3a530e<br>SHA256: 1fc7b0e1054d54ce8f1de0cc95976081c7a85c7926c03172a3ddaa672690042c</p>
<p>名称: OneDrive.Update<br>大小: 277064 字节 (270 KiB)<br>MD5: d6eae771c6cb12e17028fa35e4fba295<br>SHA1: 70767d3f7ff7736063ee76c0d9c0e90ce895332b<br>SHA256: b5d1d3c1aec2f2ef06e7d0b7996bc45df4744934bd66266a6ebb02d70e35236e</p>
<p>名称: OneDriveUpdater.exe<br>大小: 4200864 字节 (4102 KiB)<br>MD5: 792e95b64b9cf45ac8bc10d4d0f077c2<br>SHA1: e50af7ee7e0a323d8aa60b6d9b3d39ab33b004f5<br>SHA256: 60e64dd2c6d2ac6fe9b498fadac81bc34a725de5d893e7df8b2728d8dc5b192d</p>
<p>名称: version.dll<br>大小: 259584 字节 (253 KiB)<br>MD5: 76fa734236daa023444dec26863401dc<br>SHA1: a68a1b7ca1d1ddd005fd10382bf6cd0b86e74e86<br>SHA256: ea2876e9175410b6f6719f80ee44b9553960758c7d0f7bed73c0fe9a78d8e669</p>
<p>名称: vresion.dll<br>大小: 31496 字节 (30 KiB)<br>MD5: 17c1e1099b65051bb6dec71fea37315b<br>SHA1: 8ed26469afbd53da7749ef9c6ab8c7f010e9bb1e<br>SHA256: e549d528fee40208df2dd911c2d96b29d02df7bef9b30c93285f4a2f3e1ad5b0</p>
<p>名称: Roshan-Bandara_CV_Dialog<br>大小: 3149 字节 (3.07 KiB)<br>MD5: 82eb32d941b6dd63957a37453c9b0333<br>SHA1: f27a374044c73a6a5b2d926bb9468daf570b8bfc<br>SHA256: 4466017fd40c4b5fa9923928b7be3acf03825b4dd8c5fcf088992aee398b8c2d</p>
<h1 id="恶意代码分析"><a href="#恶意代码分析" class="headerlink" title="恶意代码分析"></a>恶意代码分析</h1><p>恶意样本是个iso文件，双击挂载iso，一共有5个文件，除了<code>Roshan-Bandara_CV_Dialog</code>这个快捷方式之外其他的文件都是隐藏文件（我开启了显示隐藏文件所以这里全部显示了）<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/pkcYVkL8r8c7onnwL9EF1w5vhw62dfkJ/2022081601.jpg"></p>
<p>我们查看Roshan-Bandara_CV_Dialog快捷方式指向的目标<code>%windir%/system32/cmd.exe /c start OneDriveUpdater.exe</code>，主要就是调用cmd命令执行了隐藏文件OneDriveUpdater.exe，<code>cmd.exe /c</code>命令指定执行完后会自动关闭控制台窗口<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/dXX6kHDRNssWR81fTrWXJJm9gwPAatsv/2022081602.jpg"></p>
<p>我们接着看这个快捷方式的图标文件，发现其图标文件指向<code>%ProgramFiles%\Microsoft Office\root\Office16\WINWORD.EXE</code>，由于本机没有装Office 2016所以此快捷方式的图标就无法显示，由此可见此次攻击样本十分有针对性<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/KsHlh1JQHhwYy5jOSj62iwYA7dOusMX6/2022081603.jpg"></p>
<p>其中的vresion.dll和OneDriveUpdater.exe为白文件都有Microsoft的有效数字签名<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/FDzdbkWChdKB5NVd7EIFS2RtiAVhHt60/2022081604.jpg"></p>
<p>其中的version.dll链接器版本14.29是使用1929 (Visual Studio 2019 Version 16.10 + 16.11)编译的64位DLL，可以看到编译时间戳为<code>2022-5-17 16:35:50</code><br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/6ezQBopjS5renouXhLn8vqQi9MVfFwjw/2022081605.jpg"></p>
<p>version.dll和vresion.dll的导出函数完全相同<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/bzwRWiPEWIi7WjoIrOh4yiG33qve9Muy/2022081606.jpg"></p>
<p>OneDrive.Update是一个被加密的二进制文件，猜测可能是shellcode或者pe文件<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/wSH6uEsNOFFXtasfAxI3N7xFUr6jK9gx/2022081607.jpg"></p>
<h2 id="stage0：version-dll代码分析"><a href="#stage0：version-dll代码分析" class="headerlink" title="stage0：version.dll代码分析"></a>stage0：version.dll代码分析</h2><p>接下来我们分析version.dll的DllMain函数，只调用了一个sub_180002090函数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/oNr2ahqOQUkQL9kr6nvuWo7kJ4JwbsKG/2022081610.jpg"></p>
<p>sub_180002090函数使用了WTSEnumerateProcessesA函数枚举进程</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/9GQCHrb9EyT8GbApR2j31gkY5Ir371XD/2022081611.jpg"></p>
<p>循环查找<code>RuntimeBroker.exe</code>进程</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/VAI0lG5aMATfMpv6mw3POgqP4j9MIa76/2022081612.jpg"></p>
<p>读取加密文件<code>OneDrive.Update</code>到内存</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/mPg1SM2idgVMLLbhkwYqPgLkrChYUMnB/2022081613.jpg"></p>
<p>控制台窗口打印字符串<code>&quot;Please wait...&quot;</code></p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Wa7Qki8m7GJbkfvMeUh0nfBxW03Uemd2/2022081614.jpg"></p>
<p>先调用了<code>NtDelayExecution</code>函数休眠了几秒，接着调用<code>NtOpenProcess</code>函数以<code>PROCESS_ALLACCESS</code>权限打开<code>RuntimeBroker.exe</code>进程</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/oAe2sVS5TvxVLXpOi01Lb86MW2Ma54r4/2022081615.jpg"></p>
<p>此样本的NtOpenProcess函数实现，这些汇编代码特征让我想到了<a href="https://github.com/klezVirus/SysWhispers3">SysWhispers3</a>项目</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/zN58w0C6tC5fgYdVAiknz3zUacsxM1T2/2022081616.jpg"></p>
<p>这是我使用SysWhispers3项目生成的NtOpenProcesss的syscall调用，发现除了SysWhispers3使用函数Hash方式之外汇编代码特征完全一致，可以判断此样本使用了SysWhispers3项目</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/DY21DuafAFXEwkJcjlUwnlyPHfeDKRhE/2022081617.jpg"></p>
<p>接下来我们详细分析下首先<code>SW3_GetSyscallEGG_180001D20</code>函数参数为<code>ntop</code></p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/VudltGwDzUzIlOXX5CNVnrrDgozwbLGC/2022081618.jpg"></p>
<p>主要逻辑是通过<code>gs:[60]</code>获取PEB，然后通过偏移找到<code>PEB-&gt;Ldr-&gt;InMemoryOrderModuleList</code>链表，并通过访问<code>LDR_DATA_TABLE_ENTRY-&gt;FullDllName</code> 字段使用_stricmp函数判断找到ntdll.dll</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/tT3fwcohOmDsWksUFXxEcU8ExesVIEhx/2022081619.jpg"></p>
<p>接下来通过解析ntdll.dll的PE结构获取导出函数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/e9MYysyNIENLX9bUfkgUmcmqvGINluzA/2022081620.jpg"></p>
<p>第一个导出函数名称</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/7KqXu3nEKmYz8UvftALV7TKYK1zDgUP3/2022081621.jpg"></p>
<p>memcmp函数对比直到找到导出函数NtOpenProcess</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/YvGluzzghaz7NXhFkE0TJOaDahRNv9Nv/2022081622.jpg"></p>
<p>最终获取到导出函数地址</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/VR7EpFdBgHGBWldDsahrWkJncFvGu8Se/2022081623.jpg"></p>
<p>接下来通过搜索函数NtOpenProcess的OPCODE特征找到syscall（0F05）的地址（EGG）</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/5XbTOcDcEExCub2HWtwLBsQss3DakuFE/2022081624.jpg"></p>
<p>接下来分析<code>SW3_GetSyscallNumber_180002000</code>函数，主要逻辑还是通过OPCODE特征搜索找到syscall id，关于syscall id对应的函数在不同windows版本下不同可以在<a href="https://j00ru.vexillium.org/syscalls/nt/64/">j00ru</a>的博客查询</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/xmvhX83sLp5tSexF3JwupUpsFW9D88HM/2022081625.jpg"></p>
<p>此时RAX为NtOpenProcess函数的syscall id：26，r15为syscall的地址</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/esSsRoJy0aQhhY6pryh5OUHkhKM4m5t4/2022081626.jpg"></p>
<p>通过syscall调用NtOpenProcess函数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/tlX9CzokPefcsGg6pzRXtd4p5dOU1CKW/2022081627.jpg"></p>
<p>接下来使用硬编码的xor密钥<code>jikoewarfkmzsdlhfnuiwaejrpaw</code>解密<code>OneDrive.Update</code>，解密大小为0x493E0</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/sqUeL6YSvOfNL3fFMqVNFHp4RQY9DkHm/2022081628.jpg"></p>
<p>调用了<code>NtCreateSection</code>函数创建<code>0x493E0</code>大小的<code>PAGE_EXECUTE_READWRITE</code>内存权限，<code>SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE</code>访问属性的section</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/cWV99tFuIk8xh7nu3uU4mM17PfLw1F5a/2022081629.jpg"></p>
<p>接着调用<code>NtMapViewOfSection</code>函数将section映射到本进程虚拟内存</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/YYyVcvWIfKLXylyRwEukCoHj4QkGyrTk/2022081630.jpg"></p>
<p>并调用<code>NtMapViewOfSection</code>函数将section映射到<code>RuntimeBroker.exe</code>进程虚拟内存</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/fr9Dt1NIWBBQtKNH37o1taXggvmBNom9/2022081631.jpg"></p>
<p>使用memmove函数将解密后的shellcode复制到本进程section共享内存空间，此时section内存会同步映射到远程进程<code>RuntimeBroker.exe</code>进程虚拟内存</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/qhnJYmOrcL3Q7L3itrvBYzbBRwlAqLAD/2022081632.jpg"></p>
<p>然后调用NtCreateThreadEx函数在RuntimeBroker.exe进程中创建远程线程执行注入的shellcode</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/eXlBYBySVCcOkpol8pRAGNyS7BH0DgrM/2022081633.jpg"></p>
<p>我们使用processhack工具查看<code>RuntimeBroker.exe</code>进程内存可以看到shellcode已经注入成功</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/AMAUHbw4ftlpYP9wFMDIRmyhj2rd6ozE/2022081634.jpg"></p>
<h2 id="stage1：OneDrive-Update代码分析"><a href="#stage1：OneDrive-Update代码分析" class="headerlink" title="stage1：OneDrive.Update代码分析"></a>stage1：OneDrive.Update代码分析</h2><p>为了方便调试我将stage0解密后的shellcode从内存中dump下来并使用自写的shellcode loader加载调试分析，shellcode开头有巨量的<code>mov</code>和<code>push</code>执行的组合，通过压入栈中的数据可以判断大致是在初始化数据和函数调用要用到的参数等等</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/HXTKTGSsbK3vW83eFRK1WxhiLrBUKx6S/2022081635.jpg"></p>
<p>在偏移0x43750处才开始主要逻辑</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/OOqHoIY02Bjp8qNOOz4IXD5jfT16Fy5M/2022081636.jpg"></p>
<p>可以看到刚刚压入栈中的众多数据包含了一个PE文件并且此PE文件的Dos头的MZSignature（0x5A4D）被抹除防止EDR进行内存扫描查杀，通过访问0x3C位置AddressOfNewExeHeader开始解析此PE文件</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/bumA705QuqgP0KY00lAIwuvgSe6rbWph/2022081637.jpg"></p>
<p>最终获取导出函数的RVA：0x92E0</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/u4L1QnJdbKdjfFGvAIRvX80i03OWx0d9/2022081638.jpg"></p>
<p>接下来的逻辑还是熟悉的通过<code>PEB-Ldr-&gt;InMemoryOrderModuleList</code>获取ntdll.dll的基址</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/quFSRNufoi7qsQz1lW1CROOCViqyVKzP/2022081639.jpg"></p>
<p>然后调用FindHashFunAddress_5137AE函数通过函数Hash获取对应函数的地址</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/HBRFVyPH6uVaBYsGsDgdW0flEIw2CLuL/2022081640.jpg"></p>
<p>通过解析ntdll.dll的PE结构获取导出函数名称表</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/KmqmI8RVwmhbEtoP1JNPBuJ2hMYBv6VN/2022081641.jpg"></p>
<p>并对导出函数名进行ror13 Hash然后对比目标函数Hash直到找到需要的函数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Q6BWVjYvqK2M9nemMjBFdLbixwL2quuK/2022081642.jpg"></p>
<p>获取到需要的导出函数地址后会调用CheckFuninlineHook_51375B函数进行检查</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/hkkolE2slydel1Y6zwIQ27DNMwdVx5F7/2022081643.jpg"></p>
<p>首先检查函数头是否被下了int3软件断点（0xCC），然后通过检测OPCODE编码E9（jmp）判断函数是否被EDR给inlineHook，如果函数正常则通过偏移获取函数的syscall id</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/0N0SmmbqVpYXo1vL9ixR27fg48C1tJEW/2022081644.jpg"></p>
<p>接着将参数压栈，通过syscall调用<code>ZwAllocateVirtualMemory</code>申请<code>PAGE_READWRITE</code>权限的内存</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/znCT0rvWeyXyOKjUK00f5hza2N7WJr9z/2022081645.jpg"></p>
<p>接着又申请了一块内存<code>PAGE_READWRITE</code>权限的内存</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/4DMwEziOz71QX8RuukDXPDWX7iccAgHL/2022081646.jpg"></p>
<p>申请完内存后调用了CopyPeToAllocAddress_513815函数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/1UXGJ75rfCsH4e1vagHHUtHcPXpUSx8r/2022081647.jpg"></p>
<p>此函数将栈中的PE文件（0x3240）大小的内容以每次QWORD大小复制到申请的虚拟内存中</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/XYtv1i6BTH28pzCaGzmamr2TeLpzRTPA/2022081648.jpg"></p>
<p>PE文件复制完成</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/VJMRYv7METQBdMBvMkMPJSkNvfISHG0S/2022081649.jpg"></p>
<p>接着调用 MemSetPeMemoryFeatures_513805函数将Dos头除了AddressOfNewExeHeader字段以外的内存置0，防止EDR扫描内存查杀</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/ffSHEk3Ve0aUinxwwLPLO2fJAvpmiiOS/2022081650.jpg"></p>
<p>又调用了MemSetPeMemoryFeatures_513805函数将DosStub部分的内存置0</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/QdWtPnYJQkaTVzySbAdeb3PL4iw8zACq/2022081651.jpg"></p>
<p>接着调用CopyBase64ToAllocAddress_513820函数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/YvJrJAEvCQkYfp7NsaVwfQqoWjarR1iS/2022081652.jpg"></p>
<p>将0x148字节大小的Base64编码数据复制到申请的第二块虚拟内存中</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/8uBVk4sxHNfgpfNqx3581AL9KH5rLezc/2022081653.jpg"></p>
<p>复制完内存后还是通过调用FindHashFunAddress_5137AE函数通过函数Hash获取ZwProtectVirtualMemory函数地址</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/1yBtJAfRF8zlzCVT7yYw18ewJgyEy7q6/2022081654.jpg"></p>
<p>调用ZwProtectVirtualMemory将存放PE文件那块内存属性改为<code>PAGE_EXECUTE_READ</code>属性</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/XDoHP1KLy26XeIgvWrsOGPOUzf3LASko/2022081655.jpg"></p>
<p>获取了ZwCreateThreadEx的syscall id</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/9niKycraf9n6Anf6NixPXdQzt8Idg4Tt/2022081656.jpg"></p>
<p>调用ZwCreateThreadEx执行的函数为函数开头获取的导出函数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/aDCuNiqjKusDRVEXOCGdBvo5HEYUkBem/2022081657.jpg"></p>
<p>调用ZwWaitForSingleObject函数等待线程执行完毕</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/rq65VVVGGG59gpx8vpuWe4RAnzlOcktp/2022081658.jpg"></p>
<h2 id="stage2：ReflectiveDLLInjection代码分析"><a href="#stage2：ReflectiveDLLInjection代码分析" class="headerlink" title="stage2：ReflectiveDLLInjection代码分析"></a>stage2：ReflectiveDLLInjection代码分析</h2><p>stage1创建的线程执行的函数入口，搜索内存找到Nt头的Signature（PE）地址，通过kernel32.dll的hash获取基址</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/gHGWXOFCrwhPxswspQ2fjyl6zBxmhi6S/2022081659.jpg"></p>
<p>访问PEB-&gt;Ldr-&gt;InMemoryOrderModuleList并对FullDllName进行ror13 Hash</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/b8tO5kgDXivn3uMWG7v3auJBh5FyfAKj/2022081660.jpg"></p>
<p>对比Hash正确</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/ODnjChHOYjBbIayNVU81CdhJxMAtbWmC/2022081661.jpg"></p>
<p>获得kernel32.dll基址</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/bVaLPCjXWknm3Xz5Gksm9ImEIX2m40ji/2022081662.jpg"></p>
<p>函数GetNtdllAddress_66b2c0通过PEB加偏移获取ntdll.dll的基址</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/OxBEuhF6k2qrEwBsejlc6yYaMC7Ved3I/2022081663.jpg"></p>
<p>接下来调用GetFunAddressByHash_668050函数通过Hash获取6个对应函数的地址</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/nVQPtwR1slb2XzCoL0wydeGoAEz5brXU/2022081664.jpg"></p>
<p>通过解析kernel32.dll的PE结构导出表，对导出函数进行Hash对比找到对应的函数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/2n0Rfnpwo54QgeFMxH5zeuLr5IX4O2Tk/2022081665.jpg"></p>
<p>成功获取LoadLibraryA函数地址</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Mv7wlTJjQNnL0Q9F2Tmb7mgFciAdWh0l/2022081666.jpg"></p>
<p>获取完需要的函数地址之后，对于ntdll的导出函数进行inlineHook检测并动态获取对应的syscall id</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/9DbliXnhDOiIQ08J2Ip1nekJ0gX2xr4p/2022081667.jpg"></p>
<p>检测函数是否被下int3软件断点，并检测函数头前7个字节OPCODE是否和函数固定特征相同，最后通过固定偏移获取syscall id</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Tpp0jk9gf1KGvb0Ksk0bur1gf0kS40g3/2022081668.jpg"></p>
<p>通过BRc4官网的功能介绍可知检测EDR的HOOK是BRc4的主要功能之一</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/evRcqHDuBTEC0rcQIaCKljOlCP75arqq/2022081669.jpg"></p>
<p>此时rax为动态获取的syscall id</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/QOrvhBbh9pVDHzGRYFAfpfhmbqfPFBw9/2022081670.jpg"></p>
<p>通过此函数获取了4个ntdll的导出函数syscall id</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/HhwRUiBXIdUCfPscR7XMHCktJWW7ouDk/2022081671.jpg"></p>
<p>syscall（间接系统调用）也是BRc4官网介绍的主要功能特征</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/N6vr5XiKu4KkkTEgfaJwK0BIBb1kRPpH/2022081672.jpg"></p>
<p>调用NtSetInformationProcess函数并设置参数<code>PROCESS_INFOMATION_CLASS</code>为0x28</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/5I5wjcd9YOzT3QISLF3DvSKOjoCOFOAn/2022081673.jpg"></p>
<p>通过syscall id调用NtSetInformationProcess函数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/PE1nilWhqb4uFigwW9XOzAw5FI5EnIvj/2022081674.jpg"></p>
<p>调用NtAllocateVirtualMemory函数申请了<code>PAGE_READWRITE</code>权限的内存</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/r8p0hN0lBl7CHulWkEbQBl0UmWMjwbXt/2022081675.jpg"></p>
<p>syacall id调用NtAllocateVirtualMemory函数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/MPbvOCsaXdWfrEcam7qyp0hSAWIddxrO/2022081676.jpg"></p>
<p>接下来将PE头0x400字节复制到了新申请的内存，通过前面获取的函数地址和此复制操作有分析过类似样本的应该可以大致推断这是<a href="https://github.com/stephenfewer/ReflectiveDLLInjection/blob/master/dll/src/ReflectiveLoader.c">ReflectiveDLLInjection</a>（反射式注入），主要逻辑就是模拟系统的PE Loader将PE文件复制到可执行内存中并修复IAT处理重定位数据然后直接调用内存中的函数执行，虽然这是10年前发布的技术但metasploit和cobalt strike等等框架还是普遍有使用ReflectiveDLLInjection技术，此方式可以避免文件落地以减少EDR查杀</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/X3yDeTdB0168ReWghNpX3kssFmxhK8h1/2022081677.jpg"></p>
<p>接着将全部section逐个复制到新内存</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/h2n5BuN3oYbM1W5V79WfoMSPl2hDRTkk/2022081678.jpg"></p>
<p>复制下一个section</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/LpgC2XbzsgyfLXEnXBs1Xli5Flm6VPkJ/2022081679.jpg"></p>
<p>复制完全部secsion后开始获取IAT函数地址填充修复IAT</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/RA5C2YzX6VMIp3VVR9k3XuGrXY9BuCPP/2022081680.jpg"></p>
<p>循环直到修复完IAT</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/rFaNAYvo5fAsYxGLc0A63CUEWW2KcnCq/2022081681.jpg"></p>
<p>修复重定位数据</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/NvM5cjnQJnTqomaqI9AYvyFjikQI6Hla/2022081682.jpg"></p>
<p>调用NtFlushInstructionCache函数刷新缓存</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/vmKre3o4SUsgaMmGVubjIXKElwxBM8H1/2022081683.jpg"></p>
<p>调用NtProtectVirtualMemory修改各个section的内存权限</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/mvDzxFFLTxhQeNlnIqiTdVsV75H7Q2Ce/2022081684.jpg"></p>
<p>所有section被更改的内存权限</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/pL9n4J5sD2uv81QdfHSHNCYn8cXb33Gu/2022081685.jpg"></p>
<p>我们使用processhack工具查看内存中各个区段的权限</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Dv70B8rgkDdwhcGYbG8yLBhCxseInVXx/2022081686.jpg"></p>
<p>之后将PE头0x200字节内存置0，防止EDR扫描内存特征查杀</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/hhf2G9MWIYFq9hMtLu9zQSmCSzSepNpE/2022081687.jpg"></p>
<p>最后调用dllmain</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/krpgAYFX0jlul5V5Xq08M6hiqVTj3T2S/2022081688.jpg"></p>
<h2 id="stage3：DllPayload代码分析"><a href="#stage3：DllPayload代码分析" class="headerlink" title="stage3：DllPayload代码分析"></a>stage3：DllPayload代码分析</h2><p>我们将内存中的PE文件dump出来，可以看到此PE文件为MinGW-w64编译的x64 DLL</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/suIHrPux8ARNsIzdDBx8KwHsMH3i2wVS/2022081689.jpg"></p>
<p>编译时间戳为<code>2022-3-26 4:51:36</code>，一共有11个sections</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/H75i2Lg31opJ99LxHbbCPqPFTl7VGubO/2022081690.jpg"></p>
<p>有一个无名导出函数为ReflectiveDLLInjection</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/8P2eSqllRFXgETIwwQ7qmoHcssKTeqct/2022081691.jpg"></p>
<p>接下来我们分析dllmain的两个函数sub_7A1500和sub_7A1FB0</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/8P2eSqllRFXgETIwwQ7qmoHcssKTeqct/2022081691.jpg"></p>
<p>sub_7A1500函数通过多个时间戳函数和进程线程ID异或获得12位的唯一ID</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/GflVSb4IGmp1s7fK0M2ughRKTkoxP4jp/2022081693.jpg"></p>
<p>sub_7A1FB0函数主要检测确保内存中PE文件的<code>MZSignature（MZ）</code>和<code>NtHeaderSignature（PE00）</code>被抹除</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/56yEYYagh47Shf7qdYKWvtTeEcWLOQks/2022081694.jpg"></p>
<p>接下来分析主要的核心函数，通过Hash获取VirtualFree函数释放了不需要的两处内存</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/1m73eiU3Ejz5VdFiVaTAIiL8Q5UkG511/2022081695.jpg"></p>
<p>SendRecvDataC2Server_61F89060函数就是主要的加密解密和收发数据到C2服务器</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/AitAEKYWQXpAglfzi8FXsaOmihbdykRG/2022081696.jpg"></p>
<p>GetAllNeedFunAddressbyHash_61F83A30获取了全部需要用到的函数地址，首先获取了kernel32.dll中需要的函数（由于篇幅限制只截取了部分获取dll导出函数的截图）</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/6BNeebq8CfUez2a5bLL63mDk134uzySV/2022081697.jpg"></p>
<p>获取ntdll.dll中需要用到的函数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/1m5ojX6guzMvPwfAPSyNrWCCl9Dbo1ND/2022081698.jpg"></p>
<p>除了获取kelnel32.dll和kernelbase.dll和ntdll.dll基址使用了PEB加Hash方式，获取其它DLL都使用RC4密钥<code>bYXJm/3#M?:XyMBF</code>解密dll字符串并使用LoadLibraryA加载</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/k5Qxj2rXL048919MwcnPpTM361di7yqh/2022081699.jpg"></p>
<p>获取通过syscall方式调用的ntdll.dll的导出函数syscall id</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/4CBAffwlnFB40iobkikMxs0HYKqSAcxS/20220816100.jpg"></p>
<p>最后获取了wininet.dll中的导出函数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/8siV3hnTmDVmpM2z1L6pw5X5akp7Cen0/20220816101.jpg"></p>
<p>接下来DecryptBase64ReqHeader_61F88DC0函数主要解密了base64参数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/PQ2UAA8KBdJm4DcI23g17u2zWl0Qrr9X/20220816102.jpg"></p>
<p>initDecBox9_61F8B100函数初始化了Brute Ratel C4自定义加密算法需要用的9个box[256]，初始化方法将box中每位元素减1</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/SI2rp362Ve4v16TBerD5zKSXugyINP7G/20220816103.jpg"></p>
<p>此为其中一个box</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/oqPtzjMP7e3edr4ykC8kgyV5sfdfMqW0/20220816104.jpg"></p>
<p>base64解码</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/WeDmH1ho7XRq54aTkaSYJu06Wpg45PRt/20220816105.jpg"></p>
<p>使用了CryptStringToBinaryA函数解码base64，可以看到解码后的数据还是乱码</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/JOhIvf7ulRETGWTwUVdmvSqioRPtQjVS/20220816106.jpg"></p>
<p>之后使用rc4算法和硬编码的密钥<code>bYXJm/3#M?:XyMBF</code>解密后的数据可以看到有C2的ip地址User-Agent以及一些配置信息</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/fzMB3xvfM7lXWd5Q3PCWtJI79PRXx7mG/20220816107.jpg"></p>
<p>对于解密的User-Agent<code>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36</code>和Brute Ratel C4官网的Documentation的Listener Profile配置教程中User-Agent完全一致，可以判断此样本就是Brute Ratel C4生成的payload</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/c9cL9TKSdCECYMMSVBgVUIOiLUCOpbnD/20220816108.jpg"></p>
<p>base64解码配置数据头的<code>eyJjb29raWUiOiI=</code></p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/YTVqBpUpNyEmFvz73OckohBUvlxDzYw4/20220816109.jpg"></p>
<p>base64解码<code>In0=</code></p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/dIW77tKXTrl5x1o6GmsWjlhTcOXR6cIB/20220816110.jpg"></p>
<p>接下来GetSysInfo_61F99FC0函数主要是调用函数获取了用户名进程PID系统版本和位数等等信息</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/j8EbJX5WzRvJYPUhvLgf7w6LnRVN0F94/20220816111.jpg"></p>
<p>获取当前进程的绝对路径</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/w4CtGsdM4FDiuz6niSl5qSe9M9t51Luh/20220816112.jpg"></p>
<p>并使用base64编码</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/JhugO0pmu1rpAX8IyragDVF53S5gtuM2/20220816113.jpg"></p>
<p>获取完数据初始化winsocket版本为2.2</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/BTwVMGtsS25U2PAjmRIq1IKNWx4fBphK/20220816114.jpg"></p>
<p>函数EncryptDataAndConnectC2_61F8C760首先将将获取到的的系统信息格式化</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Nb2Bc8Ki4DiOLGhNHp6LkbOnvMOOMhYy/20220816115.jpg"></p>
<p>格式化后的数据</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Ii45uQOzpofNYwI6pYGNxERoLu8PkhGs/20220816116.jpg"></p>
<p>这里使用了Brute Ratel C4自定义的加密算法密钥<code>2Q73HI7Q0OD5BRN7</code>加密了数据</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/WDfMP17Mk5Q4C92QYH3lmj9UIoq3OCR2/20220816117.jpg"></p>
<p>关于Brute Ratel C4自定义的加密算法官网有进行说明，此加密用于加密和BRc4服务器之间的网络数据，这层加密是在ssl层之下</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/ML5lUKFeu7fEkr2LhjzpweyWJYIQy6hp/20220816118.jpg"></p>
<p>对于Brute Ratel C4的自定义加密算法其实就是一个比较复杂的xor加密，这里使用我逆向还原的c++代码，关于完整的加密解密算法源码感兴趣的可以去我的<a href="https://github.com/yauv/brc4encrypt">github</a>，首先InitXorKeyBox函数根据key<code>2Q73HI7Q0OD5BRN7</code>生成160字节xorkey，获取key的后4字节传入replaceFourByteKey函数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/OCaLLAcuX8TurBiOAoGKzD1RGqQQsJtz/20220816119.jpg"></p>
<p>replaceFourByteKey函数首先将4字节的key进行ror 8，然后以第1个字节数据当作g_Box1的数组下标取出值异或g_Box2[g_replaceIndex]，g_replaceIndex默认值为1每次调用replaceFourByteKey函数值+1，这是第1个字节的处理方式</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/DAxH6alwOYaenvUVh3X47bwcEVNJIMm8/20220816120.jpg"></p>
<p>2到4字节处理方式是直接将数据当作g_Box1的数组下标取出值直接进行替换</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Jqx76yLfd8PemB9dsPYmNmqhENrnCN8g/20220816121.jpg"></p>
<p>replaceFourByteKey函数处理完的4字节数据会和key的前4字节异或生成第二组xorkey的前4字节</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/7ebBzFDjhkm6r51A1aG9zNGD4vY1yS1X/20220816122.jpg"></p>
<p>第二组xorkey后面每4字节都是通过前4字节的key异或前一组xorkey的后4字节，这里<code>33 ^ 48</code>生成的就是第二组xorkey的第5个字节，剩下的以此类推</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/iDO16U3KBf8YFuPnBHFJCkYxyWjagAez/20220816123.jpg"></p>
<p>通过以上流程一共176字节11组xorkey生成完毕</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/A18p1Cr85uh2j155LgHyKDvbwe4Nga0A/20220816124.jpg"></p>
<p>接下来这是EncryptData函数的主要逻辑也就是全部的加密过程，每次加密16字节的明文数据</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/dLTfAD59iCEU7cjkYxONzndJ9q5muuqU/20220816125.jpg"></p>
<p>首先调用MyXor函数使用第一组xorkey逐字节和明文数据进行异或</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/IggKFykyfrbowf5eBL26wl94zTVV6NUU/20220816126.jpg"></p>
<p>接着replaceBoxData函数将数据作为g_Box1的数组下标进行替换</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/agxCBSeE2qRqzdcxOiN35LHakL45uEAK/20220816127.jpg"></p>
<p>接着调用ByteOutOfOrder函数将数据乱序</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/z8RFvNXblW3FvYyY5W9T4KyKxThDMg10/20220816128.jpg"></p>
<p>boxXorData函数一共是处理了16字节，我这里就贴了前4个字节的图，因为加密方式都相同主要就是数据作为g_box3和g_box4数组下标取出的值进行异或</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/NMmULqPIP7uBgbXRnTqPTSnXzRF6d7zW/20220816129.jpg"></p>
<p>再次调用MyXor函数对数据进行异或，本次使用的就是第二组xorkey，这里循环9次前面的3个函数流程相同，MyXor函数一共使用9组xorkey进行异或加密</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/WNjODz2UdWVMC0ustElwvU5cHo7lfXYw/20220816130.jpg"></p>
<p>最后一层加密除了没有调用boxXorData函数其他的调用顺序和9次循环加密里的逻辑相同，至此16字节的明文数据加密完毕，开始加密下16字节的明文数据</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/CShdgUuDBr8YQSFarTY8vs9MbzDYXa3Q/20220816131.jpg"></p>
<p>将加密后的数据进行base64编码</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/7Lny6w7WDGKHv3K75e2XCe7QSRyHSsjM/20220816132.jpg"></p>
<p>使用InternetOpenW函数设置User-Agent为<code>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36</code></p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/FtHyiHAz70w4Hs89VBW2UgdY2nbeyaG0/20220816133.jpg"></p>
<p>InternetConnectW函数设置C2的ip地址<code>174.129.157.251</code>和端口<code>443</code></p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/5sR7lEYRQTTvGqvsv8wOJO5sN1V5HMhx/20220816134.jpg"></p>
<p>HttpOpenRequestW函数涉资请求类型为POST并且请求路径为<code>/content.html</code></p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/pPH2RwbnzwCR2dSGffYcvU2wMiSQCiTy/20220816135.jpg"></p>
<p>InternetSetOptionW设置Internet选项为<code>INTERNET_OPTION_SECURITY_FLAGS</code></p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/EczUQwvQwlWbdejRKBeWLyhJgIotLJuk/20220816136.jpg"></p>
<p>HttpAddRequestHeadersW函数参数<code>HTTP_ADDREQ_FLAG_ADD</code></p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/a1RL2uS0yusXwQMJ80HCL6Y9dV913Vey/20220816137.jpg"></p>
<p>向C2发送POST请求</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/0awYuT7SriNDfL4XN4OYMa2zJoldLFWT/20220816138.jpg"></p>
<p>COFFLoader（BOFs）功能部分代码</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/zQgcSx9JTCIJbMtp9t65ITxd6q8Wuejm/20220816139.jpg"></p>
<p>C-Sharp内存加载部分代码</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/nltYbh4LmMM1jUlFshLRlzsllSkpOq6v/20220816140.jpg"></p>
<p>由此分析对比官网介绍的C-Sharp、BOFs内存加载功能</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/1T6hWdwDryCeTVeg1kqzrieVM0EFB6OH/20220816141.jpg"></p>
<p>ETW patch功能使用的方案是直接将EtwEventWrite函数头改写C3（ret）让函数直接返回，由于没有动态调试我通过自己写的ror13Hash小工具确认函数Hash</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/oQYKNV7G6vnqSM2fYeNeKCjs7RHSxRwb/20220816142.jpg"></p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/0YagYKcrwsX8q1hvWOVWLvBfBBpiexhJ/20220816143.jpg"></p>
<p>AMSI patch的方案是将AmsiScanBuffer函数头改写为<code>B8 57 00 07 80 C3</code>（mov eax,0x80070057;ret）</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/oMekluW6pnPjeXt2MeKQgD2SPzCTxJov/20220816144.jpg"></p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/bq6vo5kGkUqGoGeM9hyR40SB3HaU9yzA/20220816145.jpg"></p>
<p>我们反汇编amsi.dll可知如果AmsiScanBuffer函数判断传入参数错误的话会跳过扫描分支过程直接将返回值0x80070057存放eax并返回，所以这里的patch方案也是直接将0x80070057存放eax并直接ret返回</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/w4oghz5hn3AnT2whoA4JyohtTU5WYSQO/20220816146.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Brute Ratel C4是一款非常优秀的商业红队C2框架，使用了众多用于规避和检测EDR的技术，在最新版的BRc4 v1.1（Stoffel’s Escape）的更新日志中作者宣布已经对核心程序进行了重写以隐藏内存的的几处痕迹，并且不再更新试用许可证，新申请试用许可证只会获得 v1.0.x 版本的最新更新，作者称此举是为了防止试用用户将最新的payloads上传到Virus Total，可见BRc4作者为了对抗EDR厂商获取最新的payloads分析以进行针对性查杀的努力，BRc4作者的总结很到位这是一场EDR和BRc4之间的猫捉老鼠游戏。</p>
<hr />]]></content>
      <categories>
        <category>样本分析</category>
      </categories>
      <tags>
        <tag>Brute Ratel C4</tag>
        <tag>BRc4</tag>
        <tag>RedTeam</tag>
        <tag>syscall</tag>
        <tag>ReflectiveDLLInjection</tag>
      </tags>
  </entry>
  <entry>
    <title>NerbianRat样本分析报告</title>
    <url>/nerbian-rat-sample-analysis-report.html</url>
    <content><![CDATA[<p><strong>本篇文章为本人原创，首发于<a href="https://www.freebuf.com/articles/system/338610.html">freebuf</a></strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Proofpoint的安全研究员发现并分析了这个新型恶意软件并命名为NerbianRAT，此恶意软件使用了反分析和反逆向功能，该恶意软件是使用Golang编写的64位程序，主要传播方式为冒充世界卫生组织发送的COVID-19相关的安全措施邮件，通过邮件附件中有VBA宏的Word文档传播。</p>
<span id="more"></span>

<h1 id="样本运行流程"><a href="#样本运行流程" class="headerlink" title="样本运行流程"></a>样本运行流程</h1><p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/lrQXGo15CwxqYBDoSiNrBU9U5qEHGpR8/1.jpg"></p>
<h1 id="样本IOCs"><a href="#样本IOCs" class="headerlink" title="样本IOCs"></a>样本IOCs</h1><p>名称: ee1bbd856bf72a79221baa0f7e97aafb6051129905d62d74a37ae7754fccc3db.doc<br>大小: 280469 字节 (273 KiB)<br>MD5: d7888fea6047b662a30bf00edac4c3ee<br>SHA1: 8137670512be55796f612e41602f505955b0bb0c<br>SHA256: ee1bbd856bf72a79221baa0f7e97aafb6051129905d62d74a37ae7754fccc3db</p>
<p>名称: MoUsoCore.exe<br>大小: 5867008 字节 (5729 KiB)<br>MD5: 5d5bc970f975341558b8d2c225ca0115<br>SHA1: 4f74826ed56cda233cfc12b86fd1b7da4a9f2e56<br>SHA256: 902c65435b6b44cfda1156b0e7c6a30b2785fa4f2cbb9b1944a66f5146ec7aa5</p>
<p>名称: UpdateUAV.exe<br>大小: 3642880 字节 (3557 KiB)<br>MD5: 9cca59eec5af63e42cd845b67cf6df89<br>SHA1: 178aad6c7918cc495a908944e79143a913630890<br>SHA256: 1b8c9e7c150bacd466fbe7f12b39883821f23b67cae0a427a57dc37e5ea4390f</p>
<h1 id="恶意代码分析"><a href="#恶意代码分析" class="headerlink" title="恶意代码分析"></a>恶意代码分析</h1><h2 id="doc宏代码分析"><a href="#doc宏代码分析" class="headerlink" title="doc宏代码分析"></a>doc宏代码分析</h2><p>双击打开doc文件发现是一个带宏的文档，文档中诱导用户点击启用宏脚本</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/FjUczrL9VpMCiDj2Yt0zSsBGSWzcSSL0/2.jpg"></p>
<p>这里我使用olevba脚本来分析此word文档的vba代码</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/rMwIg6PQVu1wGNqrnc1ALAPXpOs3x4Hg/3.jpg"></p>
<p>olevba脚本已经帮我们分析出了此vba代码的主要功能，从解码的Base64字符串我们大致可以判断此vba脚本使用powershell从C2下载了payload并写入本地文件夹执行</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/fAtMHjQAFE2pF3NjvRpCtTclmtGyEaq3/4.jpg"></p>
<p>此vba代码有三个函数，GetByte和DecodeBase64这两个函数功能为解码Base64</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/cxk0Hof3zol4plqhUFTLtAmbeOiYWM34/5.jpg"></p>
<p>主要的Document_Open入口函数我们可以看到定义了很多字符串但都是经过Base64编码，这些字符串在使用之前都调用DecodeBase64函数进行解码</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/1pDqypmkR9lxvT0QxfJrfhOGFDkp8sMz/6.jpg"></p>
<p>我们将Base64字符串解码后优化代码再查看逻辑更清晰，主要逻辑就是红框中的命令行，使用cmd.exe将powershell命令行写入%temp%\util.bat，然后执行bat脚本，从<code>hxxps://www[.]fernandestechnical[.]com/pub/media/gitlog</code>下载文件到%appdata%\UpdateUAV.exe并且执行，执行完UpdateUAV.exe后将%temp%\util.bat和%appdata%\UpdateUAV.exe删除</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/xW7IuAPbP6bNTDnRtskWqq1p07dyNP7k/7.jpg"></p>
<h2 id="UpdateUAV-exe分析"><a href="#UpdateUAV-exe分析" class="headerlink" title="UpdateUAV.exe分析"></a>UpdateUAV.exe分析</h2><p>我们查看从C2下载的dropper文件，通过详细信息可以看到，文件详细信息伪装成Windows系统程序，这里还可以发现此dropper的原始文件是nsoobe.exe</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/3XGcshT1wqwvhSXkgXW0p79CUBpdAoW0/8.jpg"></p>
<p>使用DIE工具查看UpdateUAV.exe发现此程序是64位程序并且使用了UPX3.9.6压缩壳进行加壳</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/p6cO4FxDjdp7fNpx9Q5xGQuM8WV8weFM/9.jpg"></p>
<p>我这里使用了UPX -d命令直接进行自动脱壳，如果遇到了修改版的UPX就需要手动脱壳，脱完壳文件体积膨胀到了将近一倍</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/DYz7H4k4a7AgtWBlmGregNvWkFrbLwvH/10.jpg"></p>
<p>脱完壳我们在使用DIE工具查看此UpdateUAV.exe是使用Golang编写的，Go编译器版本号为1.15.0或以上的版本</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/nrzzGQPN32KD3IG4l0diwk6O3o1XbArw/11.jpg"></p>
<p>要想确定精确的Go编译器版本可以通过搜索字符串<code>go1.</code>关键词，可以看到UpdateUAV.exe使用的是go1.17.3版本编译器，注意此方法在遇到去除符号信息和严重混淆的样本可能无效</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/2zT7YbFnhuqEFp4XgNfrS7CRH4uRMj6A/12.jpg"></p>
<p>这里直接使用IDA打开文件进行分析，查看main函数发现此Golang程序的符号信息都在，代码并没有被加密或者混淆，我们甚至可以通过函数符号名分析出函数的大致功能，比如函数main_hideWindows可以推断是隐藏进程窗口</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/RsWzhYxTJQ9nKHeK8nBcuLdzG64IGz1m/13.jpg"></p>
<p>我们使用x64dbg进行动态调试，这里为了方便调试我们手动关闭掉随机基址，使用010Editor打开PE文件将Nt头中的扩展头中的DllCharacteristics前1个字节改为00就关闭了PE文件的随机基址，这里原始是字节60 81</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/PTwrV4T8h2lEeNhoKV5AfU32tTHR00FD/14.jpg"></p>
<p>我们改为00 81并保存至此已经成功将随机基址关闭</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/1K1UWWEuI2ILAuBnF80g5RBB2BCHWcHY/15.jpg"></p>
<p>我们此时再把IDA中的符号信息导出成MAP文件并导入x64dbg，打开IDA选择File-&gt;Produce file-&gt;Create MAP file然后选择保存位置，把全部选框都勾上确认</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/vxDfCes9FO8tpMEGrfYXKwCQX6r4ANyH/16.jpg"></p>
<p>然后使用x64dbg的SwissArmyKnife插件导入MAP文件</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/aRhUOSxfMRdwuH2iEcRnJeBAyrHCHeFd/17.jpg"></p>
<p>当x64dbg导入MAP文件后通过查看IDA中的main函数地址并下断点，MAP文件导入x64dbg后让我们可以和IDA分析更好的同步</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/5ft13GjlwJGWeMBK8Eht4w5D4kmebwBF/18.jpg"></p>
<p>首先分析hideWindows函数，通过函数名可猜测此函数是隐藏控制台窗口，首先使用GetConsoleWindow获取控制台窗口句柄</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/LUrp0PgPDFUL3YP2D0sunmpyJCbGoIxS/19.jpg"></p>
<p>最后调用ShowWindowAsync函数使用SW_HIDE参数将控制台窗口隐藏</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/FN3DFqAn2EfW32LtQ2iyUiYHMH7XYbmW/20.jpg"></p>
<p>接下来分析checkEnvironment函数，可以看到此函数中调用了github上的第三方包chacal</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/OzTYDyyDVWBbQkjO9vOdpze5CrxECvUB/21.jpg"></p>
<p>我们搜索发现chacal这个包是Golang的反虚拟机框架</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/6jVCJ0TDAVPYkPqmDkKiKVq3v9eA0Vx5/22.jpg"></p>
<p>checkEnvironment函数主要通过5个函数实现，其中两个函数都是安全工具进程检测，另外三个函数主要是反虚拟机检测</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/dENTPJka8beaCCN51A9McRPhlCtVxy9y/23.jpg"></p>
<p>antidebug_processList函数调中又调用了第三方的包go_ps实现遍历windows进程</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/iFR6pv6NEMnRx9X3lzPpO1XEVqQO2Dzw/24.jpg"></p>
<p>使用了CreateToolhelp32Snapshot函数创建进程快照，然后使用Process32First和Process32Next函数组合遍历进程</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/XNhU1fqJlXonzpzkeensU6A8Vwecjgf6/25.jpg"></p>
<p>Process32Next遍历下一个进程</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/SKE7FWUtBehBJemSFBob8bg5NojbB19L/26.jpg"></p>
<p>遍历完进程后将调用github_com_p3tr0v_chacal_utils_PList函数进行对比</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/LuimWLN5iypFfKvKItKVLHBLW6K7flT5/27.jpg"></p>
<p>先对比进程黑名单列表字符串长度，如果长度相同则调用runtime_memequal函数进行字符串对比</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/x0Qo1t0EqbGArjVRHwdQoFGUEgoULmsJ/28.jpg"></p>
<p>进程黑名单列表一共有42个如下，antimem_processList函数和antidebug_processList函数逻辑都相同不过antimem_processList只检测了DumpIt.exe、RAMMap.exe、RAMMap64.exe、vmmap.exe这四个用于DUMP进程内存的工具进程所以就不贴图了</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/FhCnTxquWIqyOtewSz8usesBBtm3EDIj/29.jpg"></p>
<p>IsVirtualDisk函数首先调用了queryWMI函数，此函数封装了两个函数先调用了CreateQuery函数创建了WMI WQL查询语句</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Gy0bVBJVvs5SuumHUm6PGJEMHrfO6ufG/30.jpg"></p>
<p>然后调用wmi_Query函数使用WMI WQL语句进行查询了网卡信息</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/EqcdG0AbLYwMYYcIMBw7rSLdmEdW2dFc/31.jpg"></p>
<p>最后调用了ContainsInList函数对比网卡是否为列表中名单中的虚拟网卡，虚拟网卡黑名单列表中有三个virtual,vmware, vbox</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/tTXBOrQWKJib1mssD8bYfPhJfIF4vRxz/32.jpg"></p>
<p>接下来分析ByMacAddress函数该函数首先调用了getMacAddr函数查询本机的MAC地址</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/LRR4IKs1aOykHaLUGBdH7CuWbV4JuecP/33.jpg"></p>
<p>然后调用ContainsPrefix函数对比本机和黑名单列表的的MAC地址</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/V7ajMpnkT1VYsADTuokkedkjrwpcwH6Q/34.jpg"></p>
<p>接下来分析diskTotalSize函数，从函数符号可猜测此函数用来检测硬盘大小，通过函数的传参0x64十进制为100可以猜测此检测大小为100GB</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/bustnmFFi6jhCx134VvXVpz6PbN0gtFl/35.jpg"></p>
<p>通过分析diskTotalSize函数内部，也是调用了queryWMI函数进行查询硬盘信息，然后对比本机硬盘是否小于100GB，我的虚拟机硬盘大小为99GB十六进制0x63</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/kejHXvtTlVK3IU2fbPIcFnNyICq6crIk/36.jpg"></p>
<p>如果以上反调试检测都通过，接着使用IsDebuggerPresent检测本进程是否被调试，还调用了time_Since函数和函数开头的time_Now组合检测函数运行时间判断进程是否被调试</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/QAl9H2AMRkuXqm2EYJ3bNR3GvD0XLoUQ/37.jpg"></p>
<p>checkLocation函数使用GET请求<code>hxxps://json[.]geoiplookup[.]io</code>网站获取json格式的公网IP归属地，但是此网站屏蔽了ASN为4134的IP地址所以此处返回值为错误代码</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/FGPFkFgiF6YUKQp8jigDtwHKOSqGvFcF/38.jpg"></p>
<p>正常如果获取到了本机IP归属地会和列表中的地区进行比较，我们可以看到此列表中，只有两个具体的地区伦敦和俄罗斯在这两个中间的单词都为一些少儿不宜的话</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/vb8ilzjmfFHUTcxTK7yjlbxbahF1qSOP/39.jpg"></p>
<p>一共对比了列表中7个单词，从2到6个单词可以猜测此恶意软件的作者可能是个种族歧视主义者</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/K3ktGM8PYJTEpqNDUxGYk113aPr0iCGQ/40.jpg"></p>
<p>调用strings_Index函数进行逐一对比</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/FhSoWNFx27LVpAhVhVRkEhqBLGnGiUpk/41.jpg"></p>
<p>checkLocation函数检测如果IP归属地不在列表中则会调用downloadNerbian函数从C2服务器下载NerbianRAT主体程序</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/NIyU91w0bQlb4opzojVpSycuyuWQPKJm/42.jpg"></p>
<p>分析downloadNerbian函数，此函数首先会使用RedFile函数打开<code>C:\\ProgramData\\USOShared\\MoUsoCore.exe</code>路径中的文件</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Kx5rDmOWtV3fAFysNtWEHfJJSBJgCR4R/43.jpg"></p>
<p>如果文件不存在则会从C2下载，如果存在此文件还会判断此文件前两个字节是否为4D5A（MZSignature）用于判断此文件是否为PE文件</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/uy9omQOeUcuhwIuvWzq5wIi5nouKgHFz/44.jpg"></p>
<p>调用downloadFile函数从C2下载NerbianRAT</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Ku5uafFnkTj77otlJLrBNCr3IX09W8Vf/45.jpg"></p>
<p>如果首次从C2下载失败，还会调用cmd使用curl从C2下载</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/VEwokY5CWgs409SBA3kRPKW26pCiXfDB/46.jpg"></p>
<p>从C2下载完成后都会读取文件并检测文件头两个字节是否为4D5A（MZSignature）判断是否为PE文件</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/vaqvi4upJRhbYQXpGCDSSnMQvthbVnS1/47.jpg"></p>
<p>最后一个函数是创建计划任务实现持久化运行，首先通过CMD调用格式化好的命令创建计划任务</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/pn8VnjHsWzrqgBKLNO5Bt193lDYOcQzU/48.jpg"></p>
<p>我们可以打开计划任务查看，可以看到触发条件是每隔1小时运行一次</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/8FSUge0TuqFSUNvJCRMKfDepYnmk5Wpi/49.jpg"></p>
<p>触发操作就是启动从C2下载的NerbianRAT</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/YvX2j6REEEnUP94l4lRnblbkh1njUQCg/50.jpg"></p>
<p>如果创建计划任务成功则直接触发执行运行NerbianRAT，至此UpdateUAV.exe这个dropper程序就分析完成</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Ch3g8lV2kRtqkgN6IPPLvLngYtUkMVOB/51.jpg"></p>
<h2 id="MoUsoCore-exe分析"><a href="#MoUsoCore-exe分析" class="headerlink" title="MoUsoCore.exe分析"></a>MoUsoCore.exe分析</h2><p>接下来我们分析NerbianRAT主体程序，NerbianRAT一样使用了UPX压缩壳还是一样的流程脱壳，此样本去除大部分的符号信息，不过我们还是可以通过搜索<code>github</code>关键词查找MoUsoCore.exe的函数可以查看使用的go开源包，通过如下这些包可以大致判断出NerbianRAT的大致功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smbios包提供对系统管理BIOS(SMBIOS)和桌面管理接口(DMI)数据和结构的检测和访问：github[.]com/digitalocean/go-smbios</span><br><span class="line">Windows WMI提供了WQL接口：github[.]com/StackExchange/wmi</span><br><span class="line">桌面截图：github[.]com/kbinani/screenshot</span><br><span class="line">go的WindowsAPI封装：github[.]com/AllenDang/w32</span><br><span class="line">golang的win32 ole实现：github[.]com/go-ole/go-ole</span><br><span class="line">go的WindowsAPI封装：github[.]com/lxn/win</span><br></pre></td></tr></table></figure>

<p>golang有一种特殊的函数初始化函数，定义格式<code>fcun init()</code>，此函数会在main函数之前执行，并且同一个包可以定义多个init函数，编译时编译器会自动更名，这里可以看到main包中一共有两个init初始化函数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/ouo0j6kME3OgybnljJ7pyMQmGqCtFaew/52.jpg"></p>
<p>其中的main_init_0使用了硬编码的AesGCM加密模式的密钥解密了很多需要使用到的字符串</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/0sdXee06F2yN9KuHgfAp8GA8dt4DyM4n/53.jpg"></p>
<p>调用gcmAsm_open解密</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Gmn47sfUIvVFBelDlKxYS6lABVcPThLT/54.jpg"></p>
<p>可以看到解密出来的是一个ip地址此地址应该是和C2相关的，接下来还进行了多次解密出剩下的加密字符串</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/EaaFNgwdBrF67ythjENEeVCs80sOpi1S/55.jpg"></p>
<p>下面开始分析main函数，第一个函数调用main_I4JkbFMH还是个进程检测名单</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/B7fVDS9KKGwRAfJv5bNJgbMIBaoFtGkG/56.jpg"></p>
<p>使用了github开源的StackExchange包通过WQL语句<code>SELECT * FROM Win32_Process</code>查询了本机进程</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/dms9nLD9gXw57f5fqWRSOy4P5SMFdzW5/57.jpg"></p>
<p>对比进程黑名单列表</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/SzFhyUbtCl4cMsypeydsOfrtYTubdWg0/58.jpg"></p>
<p>接下来分析main_H5NzwUxN函数，首先获取了本机BIOS信息，然后对获取到的BIOS信息使用MD5算法进行了哈希</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/xY7nFSLOt7RNxMLOseXryDgaDIps0xIa/59.jpg"></p>
<p>然后将MD5值类型转换成16进制</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/jswllTqafHqYfyKYrJ9UdA4BG2RNX9an/60.jpg"></p>
<p>接着使用getCurrentProcessId函数获取了本进程的PID并同样对PID使用MD5进行哈希</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/sYhg2l64bYeAkn7IsPtdfU6L6iMeo5IY/61.jpg"></p>
<p>同样的将MD5值类型转换为16进制</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Yx0xrCoqsNhUYAPNzrcM9SuEMPuQOi91/62.jpg"></p>
<p>接着生成了一个唯一ID</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/46oqgDFDT7XtKlDJUA8yUPhASITv2ne8/63.jpg"></p>
<p>接着将生成的唯一ID转为大写字母</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/BuWxmUXmmIS9bX8H9RwWXK33LOoHABDU/64.jpg"></p>
<p>函数main_H5NzwUxN获取收集了主机名称等信息</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/BH5IjkQhSda7b1nvzMTLgra7qK570Dd1/65.jpg"></p>
<p>函数main_JgJWgOp中调用ReadFile函数读取了<code>args_c.txt</code>文件如果不存在此文件则跳转，暂不清楚此文件的作用可能是后期存储收集到的信息</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/LdorcwPOhPPk8rUXunUxM0rQ2Hpeqr8M/66.jpg"></p>
<p>函数main_ZPBgbOEQ读取了<code>C:\ProgramData\Microsoft OneDrive\setup\rev.sav</code>文件，此文件可能也是用来存储一些收集到的数据</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/sBRSWryMQRj714EcfBdkBtXFbDMOE0IT/67.jpg"></p>
<p>接下来main_DNKvpcvy函数实现了加解密和收发网络请求，首先格式化了一个IP地址，此地址可能是C2服务器IP地址</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/L4pqILIpGdcz5lhvUNWocEyfWiWhB5Cy/68.jpg"></p>
<p>向C2<code>hxxps://www[.]fernandestechnical[.]com/pub/health_check[.]php</code>发送Get请求判断C2是否存活</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/2AEyxmu1Ub2CLQgoenGAPQksMqw47VtD/69.jpg"></p>
<p>向C2发送Get请求</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/q4WA95sm4JvLP42aFG7nFUHTReB7S0aH/93.jpg"></p>
<p>C2返回状态码200则C2存活</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/cC7XX0Fzhi4ESMvLwJTzB7YtTy8n4kKb/70.jpg"></p>
<p>C2和本机的keep-alive心跳包</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/BRrrbgOO5rd46neu3enzXWLn4st3l5Dp/94.jpg"></p>
<p>获取了本地IP地址</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/SSO37MAeQRstOMkx8HaJEvOSdqiJqmKb/71.jpg"></p>
<p>接下来使用RSA-2048加密了0x98大小的内容，其中包含了收集到的本机基本信息</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/gDrrSbObyDGalkQMYoHKVmmd8CxnHqhf/72.jpg"></p>
<p>RSA公钥为硬编码</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/GfUojlusOMyhkMDxOAvzXge15wPeEnLp/73.jpg"></p>
<p>RSA加密后的Buff为0x100</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/IpS7gyz1W3m2wqqPluXDMSb8mu5Vcp2l/74.jpg"></p>
<p>然后拼接了0x14C大小的缓冲区</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/OBwtse1XCFucVJnVbBgw63SuNeyFOkMg/75.jpg"></p>
<p>接下来使用了AesCBC模式加密，使用补全码0x4填充了4字节到0x150大小</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/cd43O6cIIsBrPUN6GzERczbD0g7UtfUa/76.jpg"></p>
<p>使用了硬编码的32字节Aes密钥进行加密</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/KAKocQJ2BXMY1N3aXK5dmmYiCJ6OLbMJ/77.jpg"></p>
<p>使用硬编码的AesCBC密钥加密后数据</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/9WeEqU9RReY90XHhjxq5nnMQBSTkRBLJ/78.jpg"></p>
<p>将随机生成的0x10大小的数据写入AesCBC加密后的缓冲区头部</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/hmBz1DxTdSh8YMBy9bhJ1Ol4brXBBHcB/79.jpg"></p>
<p>再次拼接将8563写入缓冲区头部</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/6XhKYEVUr1tCsoGMaiRUeHwNCTj4LvjI/80.jpg"></p>
<p>函数main_P6EwC8SB是对auth_post、data_post、addr_post、port_post字段数据进行加密的函数，此AesCBC模式加密密钥是随机生成的32字节</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/n2DWJm1OIMQ8HlGmmx2WUoc4IGP9lqG6/81.jpg"></p>
<p>使用AesCBC模式加密后</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/qcQlQE6mGGBEzjh5YhLxH9K6KrmJJGat/82.jpg"></p>
<p>接着生成了70个字节的随机数</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/5hpQdxPxl8n6cEiGwfu8omTaxfsMOxTS/83.jpg"></p>
<p>使用Base64对AesCBC模式加密后的数据进行编码</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/C02zFUffO95zgrbcm37svo5nBHUiFTK0/84.jpg"></p>
<p>将随机生成的70个字节数据填充到头部，将AesCBC模式加密使用的32字节大小随机生成密钥存放在70个字节数据之后，后面的为Base64编码后的加密数据</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/DeVnFvU8hCIJFfILV3acJ4d3LlUmpEVW/85.jpg"></p>
<p>函数main_GNd3j2oz就是生成session_key字段的数据，首先调用了go-smbios包获取bios硬件信息，并使用MD5哈希</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/3Eprv3xAFjfEkmwdpU1RaPSeDxsch7Ik/86.jpg"></p>
<p>将MD5转为十六进制</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/sXXjNLeLLBGiDnXaGmXCzLal9kKAbiOj/87.jpg"></p>
<p>之后将0x40字节大小的全局变量和bios信息MD5值和字符串windows进行格式化，随后直接使用Base64对这些数据进行了编码</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/GzLnquP58soXSWVkIsacqD4a73mwwnSj/88.jpg"></p>
<p>拼接好要发送的POST请求</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/jqLvmyJYAR9YNhGQaKnD4Yt7YbzYBCOU/89.jpg"></p>
<p>发送POST请求到C2</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/29QUQpKqYGC4euulTBgGXMqa58JAWe8H/90.jpg"></p>
<p>屏幕截取功能使用了screenshot开源库实现</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/ksVfAeoa10C8IF779JO4Adzw3y9WTYl2/91.jpg"></p>
<p>屏幕截图功能</p>
<p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/yETTA2Hj33Qej4V4pjrYuC296il4UoxA/92.jpg"></p>
<p>这里我使用了golang编写了解密脚本，除了session_key这个数据单单使用了Base64编码，其他的4个字段的数据都可以使用这个脚本解密，auth_post和data_post使用了3层加密，第一层的数据使用了RSA-2048进行加密，第二层req使用了硬编码的AesCBC密钥加密，第三层8563使用了随机生成的AesCBC加密，所以我们最多可以解密两层go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;crypto/aes&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/base64&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// addr_post字段加密数据</span></span><br><span class="line">    allcryptDataBase64 := <span class="string">&quot;EcgOPkkOHFylaFoLaqoXmbKPGOzvddbJMlnTtEtlScAdeewEFwzdITJsRYdYEushByrcQJCtuqdlGSeQyCjNieJBeQSnVwNcDhtQrh06LdGa3uyRHexahEL05goQ==&quot;</span></span><br><span class="line">    <span class="comment">// 加密数据前70个字节为垃圾数据，垃圾数据后的32个字节为AesCBC加密密钥</span></span><br><span class="line">    aesCBCKey := allcryptDataBase64[<span class="number">70</span> : <span class="number">70</span>+<span class="number">32</span>]</span><br><span class="line">    <span class="comment">// 需要解密的数据为70垃圾字节+32字节的AesCBC密钥后面的Base64编码数据</span></span><br><span class="line">    cryptDataBase64 := allcryptDataBase64[<span class="number">70</span>+<span class="number">32</span>:]</span><br><span class="line">    <span class="comment">// 将加密数据进行Base64解码</span></span><br><span class="line">    cryptData, _ := base64.StdEncoding.DecodeString(<span class="type">string</span>(cryptDataBase64))</span><br><span class="line">    <span class="comment">// 使用AesCBC解密数据</span></span><br><span class="line">    decryptData := AesDecryptCBC(cryptData, []<span class="type">byte</span>(aesCBCKey))</span><br><span class="line">    <span class="comment">// 打印解密数据</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, decryptData)</span><br><span class="line">    <span class="comment">// 解密第二层数据：解密auth_post和data_post数据时再调用</span></span><br><span class="line">    DecryptoSecData(decryptData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecryptoSecData</span><span class="params">(decryptData []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 解密第二层加密</span></span><br><span class="line">    <span class="comment">// 硬编码AesCBCKey</span></span><br><span class="line">    gaesCBCKeyBase64 := <span class="string">&quot;F+h/WB8d+NYSnWX9UM6z3WxOHCIwd819TFldpsPfkrI=&quot;</span></span><br><span class="line">    <span class="comment">// 解码第二层硬编码的AesCBC密钥</span></span><br><span class="line">    gaesCBCKey, _ := base64.StdEncoding.DecodeString(<span class="type">string</span>(gaesCBCKeyBase64))</span><br><span class="line">    <span class="comment">// 第二层要解密的数据</span></span><br><span class="line">    secCryptData := decryptData[<span class="number">8</span>:]</span><br><span class="line">    <span class="comment">// 使用AesCBC解密数据</span></span><br><span class="line">    secDecryptData := AesDecryptCBC(secCryptData, []<span class="type">byte</span>(gaesCBCKey))</span><br><span class="line">    fmt.Println(<span class="string">&quot;第二层数据解密--------------------------------------&quot;</span>)</span><br><span class="line">    <span class="comment">// 打印解密数据</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%x&quot;</span>, secDecryptData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AesCBC模式解密函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesDecryptCBC</span><span class="params">(encrypted []<span class="type">byte</span>, key []<span class="type">byte</span>)</span></span> (decrypted []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="comment">// 分组密钥</span></span><br><span class="line">    block, _ := aes.NewCipher(key)</span><br><span class="line">    <span class="comment">// 获取密钥块的长度</span></span><br><span class="line">    blockSize := block.BlockSize()</span><br><span class="line">    <span class="comment">// 加密模式</span></span><br><span class="line">    blockMode := cipher.NewCBCDecrypter(block, key[:blockSize])</span><br><span class="line">    <span class="comment">// 创建数组</span></span><br><span class="line">    decrypted = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(encrypted))</span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    blockMode.CryptBlocks(decrypted, encrypted)</span><br><span class="line">    <span class="comment">// 去除补全码</span></span><br><span class="line">    decrypted = PKCS5UnPadding(decrypted)</span><br><span class="line">    <span class="keyword">return</span> decrypted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除补全码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5UnPadding</span><span class="params">(origData []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(origData)</span><br><span class="line">    unpadding := <span class="type">int</span>(origData[length<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> origData[:(length - unpadding)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>NerbianRAT使用了现在主要的恶意软件传播方式之一为通过邮件附件的带VBA宏脚本的word文档进行传播，甚至不乏很多境外APT组织也使用此方式针对性攻击，go这种跨平台的编译型编程语言正被越来越多的恶意软件开发者采用，go众多的开源包可以实现快速开发，NerbianRAT使用了众多的反逆向和反虚拟机功能加大了分析的时间和难度，并且使用了RSA和AES组合的加密手段用来传输数据，对于此类传播方式的恶意软件能做的只有加强邮件地址过滤和附件检测和加大信息安全教育普及。</p>
<hr />]]></content>
      <categories>
        <category>样本分析</category>
      </categories>
      <tags>
        <tag>NerbianRat</tag>
        <tag>golang</tag>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>一次野外偶遇窃密的浣熊RaccoonStealer v2样本分析报告</title>
    <url>/raccoon-stealer-v2-analysis-report.html</url>
    <content><![CDATA[<p><strong>本篇文章为本人原创，首发于<a href="https://www.freebuf.com/articles/system/344639.html">freebuf</a></strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Raccoon Stealer v2是一款在地下黑客论坛售卖的信息窃取器，通过恶意软件即服务 (MaaS)模式运营，用户购买订阅后可轻松进行配置并进行分发传播，一般通过伪装的破解软件下载站进行传播</p>
<h1 id="样本运行流程"><a href="#样本运行流程" class="headerlink" title="样本运行流程"></a>样本运行流程</h1><p><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/b8RG3rpDM0IFt0QI21byF9A4CHl0oBrF/2022091601.jpg"></p>
<span id="more"></span>

<h1 id="样本IOCs"><a href="#样本IOCs" class="headerlink" title="样本IOCs"></a>样本IOCs</h1><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>名称: PA$$w0rds_1234__SetupMain7–A4.rar<br>大小: 6350190 字节 (6201 KiB)<br>MD5: 916062da2e31a30e6f1ec0edc33dd4e9<br>SHA1: b34300a38b0329ec9b3d303ddf670a3b6d154d6b<br>SHA256: 1ce1ef40bf1a6edc429a326be3bccb9385d0dd4ccfb00c07972f64d232066b8a</p>
<p>名称: Setup.exe<br>大小: 761512960 字节 (726 MiB)<br>MD5: 7949b59a91d6c4b6bc005c7222d00829e<br>SHA1: 8aa525197f8ad4f0a2c5f0a549ed5ff9334d331b<br>SHA256: 3821c8468ab7f53a5aa536f3da3d1d2ef553c0b9f60682f339791886c8096b50</p>
<p>名称: Setup.exe（去除无用字节）<br>大小: 6538240 字节 (6385 KiB)<br>MD5: 657b3c0142ba7bea31c0618d38cb8a04<br>SHA1: 73ee1fe9a79c48460fb5fa9d10a09338b9e48669<br>SHA256: 7ff22cd1d3e1c8d7bf2628da60c905bd6bef4733b0d4e68e862e1598268d2481</p>
<p>名称: 36141266339446703039.bin<br>大小: 2834432 字节 (2768 KiB)<br>MD5: 24967c5d930081488e15e735d3d40d0c<br>SHA1: 080e2d4f2065d326d8842e4ca9a02ed76e74f4d5<br>SHA256: 1324ad52820961a29ef6aea13e5bb21d1bbd2169045abc61c711424f196d11f2</p>
<p>名称: RaccoonStealerV2<br>大小: 56832 字节 (55 KiB)<br>MD5: 0cfa58846e43dd67b6d9f29e97f6c53e<br>SHA1: 19d9fbfd9b23d4bd435746a524443f1a962d42fa<br>SHA256: 022432f770bf0e7c5260100fcde2ec7c49f68716751fd7d8b9e113bf06167e03</p>
<h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2><h3 id="恶意下载站"><a href="#恶意下载站" class="headerlink" title="恶意下载站"></a>恶意下载站</h3><p>hxxps:&#x2F;&#x2F;licenseprokeys[.]com&#x2F;<br>hxxps:&#x2F;&#x2F;tradecracked[.]com&#x2F;<br>hxxps:&#x2F;&#x2F;fancracked[.]com&#x2F;</p>
<h3 id="通信URL"><a href="#通信URL" class="headerlink" title="通信URL"></a>通信URL</h3><p>http[:]&#x2F;&#x2F;94[.]131[.]106[.]116&#x2F;<br>hxxp:&#x2F;&#x2F;94[.]131[.]106[.]116&#x2F;aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK&#x2F;nss3[.]dll<br>hxxp:&#x2F;&#x2F;94[.]131[.]106[.]116&#x2F;aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK&#x2F;msvcp140[.]dll<br>hxxp:&#x2F;&#x2F;94[.]131[.]106[.]116&#x2F;aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK&#x2F;vcruntime140[.]dll<br>hxxp:&#x2F;&#x2F;94[.]131[.]106[.]116&#x2F;aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK&#x2F;mozglue[.]dll<br>hxxp:&#x2F;&#x2F;94[.]131[.]106[.]116&#x2F;aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK&#x2F;freebl3[.]dll<br>hxxp:&#x2F;&#x2F;94[.]131[.]106[.]116&#x2F;aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK&#x2F;softokn3[.]dll<br>hxxp:&#x2F;&#x2F;94[.]131[.]106[.]116&#x2F;aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK&#x2F;sqlite3[.]dll<br>hxxp:&#x2F;&#x2F;94[.]131[.]106[.]116&#x2F;3f9bef70525fd0873fc9acf8b6babce9<br>hxxp:&#x2F;&#x2F;172[.]86[.]75[.]189&#x2F;&#x2F;36141266339446703039[.]bin</p>
<h1 id="恶意代码分析"><a href="#恶意代码分析" class="headerlink" title="恶意代码分析"></a>恶意代码分析</h1><h2 id="传播途径"><a href="#传播途径" class="headerlink" title="传播途径"></a>传播途径</h2><p>某天闲逛的时候搜索了一些关键词xxxx crack（搜索结果中基本都是用于传播恶意软件的网站）<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/IhPY3bVoLIzJ1CTybpmQGhjRRwda6pVG/2022091602.jpg"><br>随手点进了第一个网站后<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/p1PSBjxm8pjcubYr5eHRGQAaGkROpysj/2022091603.jpg"><br>下载链接点击下载链接下载<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/KstHQ8vqG6OkIVjd2Fb0vCFWMbk5QK45/2022091604.jpg"><br>下载链接的跳转过程一共跳转了7次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-&gt;hxxps://href[.]li/?hxxps://wqervf56kl[.]click/?i=PeStudio-Pro-9-43-Crack---License-Key-Free-Download-2022&amp;u=1663076111&amp;t=16</span><br><span class="line">1-&gt;hxxps://wqervf56kl[.]click/?i=PeStudio-Pro-9-43-Crack---License-Key-Free-Download-2022&amp;u=1663076111&amp;t=16</span><br><span class="line">2-&gt;hxxps://href[.]li/?hxxps://nhgfr7yh[.]click/Mt1JWxKprFcGNv67jDX0TqmUlgEL9s5/16/PeStudio-Pro-9-43-Crack---License-Key-Free-Download-2022</span><br><span class="line">3-&gt;hxxps://nhgfr7yh[.]click/Mt1JWxKprFcGNv67jDX0TqmUlgEL9s5/16/PeStudio-Pro-9-43-Crack---License-Key-Free-Download-2022</span><br><span class="line">4-&gt;hxxps://iplogger[.]org/Wersty-TM2poy-PASSw0rds_1234__SetupMain7--A4</span><br><span class="line">5-&gt;hxxps://www[.]mediafire[.]com/file/p99280jcivm6732/PA$$w0rds_1234__SetupMain7--A4.rar/file</span><br><span class="line">6-&gt;hxxps://download2338[.]mediafire[.]com/ixn681qdyafg/p99280jcivm6732/PA%24%24w0rds_1234__SetupMain7--A4.rar</span><br></pre></td></tr></table></figure>

<p>其中查询可知href[.]li为一款的网站重定向小工具<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/64xoXQoQtTbWQJ8xThdhhlfFMVjNraXP/2022091605.jpg"><br>跳转到nhgfr7yh[.]click页面给出了一个链接让我们复制并下载<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/JayzuBPF2SNQYaLheH78D9dv91w07jEq/2022091606.jpg"><br>我们查看iplogger[.]org发现是一个短链接生成网站，并且此链接已经被拉入黑名单，但是下载链接还是可以正常下载<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/J7xfs84zBD1cyhqTUrusr3Tg7jQlhAkd/2022091607.jpg"><br>www[.]mediafire[.]com是一个文件存储和共享应用，并且无需注册就可以上传文件并分享<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/m8Re9v6nKYJ83254dBNpTxEmJtiB4g9i/2022091608.jpg"><br>我们查看下载的压缩包大小为6.05MB<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/vmRIAMiub38EcB29kHFGeRP0cRcdguOM/2022091609.jpg"><br>我们使用密码1234解压后，发现Setup.exe竟然足足有726MB大小，并且这个图标和应用名和我下载的软件也货不对板<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/XtB49kJkDRXlojxhuBL2tjPk1L7FSblc/2022091610.jpg"><br>目前我认为还没有这么强大的压缩算法吧，那就只有一个原因这个PE文件肯定附加了很多重复的无意义字节，我们使用010Editor打开PE文件查看，果然PE文件尾部使用了大量的0x30填充，此技术主要是增大PE文件大小防止AV或EDR上传沙箱分析<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/9uUAR3UIDqzkamij25B0frjouL2TiMjl/2022091611.jpg"><br>我们去除PE尾部的0x30后PE文件缩小为6.23 MB，此PE文件是使用Visual Studio 2019链接器版本14.29（ 1929 (versions 16.10 + 16.11)）编译的32位PE文件，使用了VMProtect 3.6.0加壳<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/vjF9W2PmjyRVW2QzpoPkDeLC1i2lkODh/2022091612.jpg"><br>代码都被VM了，直接上传样本到沙箱分析<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/WlETPC9BjnVzqgRCiFNqgE6xftqvuJxO/2022091613.jpg"></p>
<h2 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h2><p>上传沙箱分析后发现威胁情报标签显示此样本来自于Raccoon Stealer家族，查看样本产生的流量特征和公开的威胁情报对比可以确定此样本应该是Raccoon Stealer v2<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/IgRjuwSLIQ8a0PTApzjs3morCB9ikvFG/2022091614.jpg"><br>首先第一个POST请求中使用的User-Agent为<code>mozzzzzzzzzzz</code>，发送的数据为<code>machineId=90059c37-1320-41a4-b58d-2b75a9850d2f|admin&amp;configId=0dcbeb99ec1adc5c2b2b94dc1e3fd2c4</code><br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/TLfCnHAN5APNVloRpCMWEh2HepeLhPC1/2022091615.jpg"><br>C2返回的数据中返回了明文配置文件，libs_开头的为要下载的dll，ews_开头的为浏览器扩展数据窃取配置，wlts_开头的为数字货币加密钱包数据窃取配置，xtntns_开头的为密码管理软件数据窃取配置，grbr_Desktop为要窃取的文件路径和文件类型，ldr_为下一阶段的payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libs_nss3:hxxp://94[.]131[.]106[.]116/aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK/nss3.dll</span><br><span class="line">libs_msvcp140:hxxp://94[.]131[.]106[.]116/aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK/msvcp140.dll</span><br><span class="line">libs_vcruntime140:hxxp://94[.]131[.]106[.]116/aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK/vcruntime140.dll</span><br><span class="line">libs_mozglue:hxxp://94[.]131[.]106[.]116/aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK/mozglue.dll</span><br><span class="line">libs_freebl3:hxxp://94[.]131[.]106[.]116/aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK/freebl3.dll</span><br><span class="line">libs_softokn3:hxxp://94[.]131[.]106[.]116/aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK/softokn3.dll</span><br><span class="line">ews_meta_e:ejbalbakoplchlghecdalmeeeajnimhm;MetaMask;Local Extension Settings</span><br><span class="line">ews_tronl:ibnejdfjmmkpcnlpebklmnkoeoihofec;TronLink;Local Extension Settings</span><br><span class="line">libs_sqlite3:hxxp://94[.]131[.]106[.]116/aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK/sqlite3.dll</span><br><span class="line">ews_bsc:fhbohimaelbohpjbbldcngcnapndodjp;BinanceChain;Local Extension Settings</span><br><span class="line">ews_ronin:fnjhmkhhmkbjkkabndcnnogagogbneec;Ronin;Local Extension Settings</span><br><span class="line">wlts_exodus:Exodus;26;exodus;*;*partitio*,*cache*,*dictionar*</span><br><span class="line">wlts_atomic:Atomic;26;atomic;*;*cache*,*IndexedDB*</span><br><span class="line">wlts_jaxxl:JaxxLiberty;26;com.liberty.jaxx;*;*cache*</span><br><span class="line">wlts_binance:Binance;26;Binance;*app-store.*;-</span><br><span class="line">wlts_coinomi:Coinomi;28;Coinomi\Coinomi\wallets;*;-</span><br><span class="line">wlts_electrum:Electrum;26;Electrum\wallets;*;-</span><br><span class="line">wlts_elecltc:Electrum-LTC;26;Electrum-LTC\wallets;*;-</span><br><span class="line">wlts_elecbch:ElectronCash;26;ElectronCash\wallets;*;-</span><br><span class="line">wlts_guarda:Guarda;26;Guarda;*;*cache*,*IndexedDB*</span><br><span class="line">wlts_green:BlockstreamGreen;28;Blockstream\Green;*;cache,gdk,*logs*</span><br><span class="line">wlts_ledger:Ledger Live;26;Ledger Live;*;*cache*,*dictionar*,*sqlite*</span><br><span class="line">ews_ronin_e:kjmoohlgokccodicjjfebfomlbljgfhk;Ronin;Local Extension Settings</span><br><span class="line">ews_meta:nkbihfbeogaeaoehlefnkodbefgpgknn;MetaMask;Local Extension Settings</span><br><span class="line">sstmnfo_System Info.txt:System Information: </span><br><span class="line">|Installed applications:</span><br><span class="line">|</span><br><span class="line">wlts_daedalus:Daedalus;26;Daedalus Mainnet;*;log*,*cache,chain,dictionar*</span><br><span class="line">wlts_mymonero:MyMonero;26;MyMonero;*;*cache*</span><br><span class="line">wlts_xmr:Monero;5;Monero\\wallets;*.keys;-</span><br><span class="line">wlts_wasabi:Wasabi;26;WalletWasabi\\Client;*;*tor*,*log*</span><br><span class="line">ews_metax:mcohilncbfahbmgdjkbpemcciiolgcge;MetaX;Local Extension Settings</span><br><span class="line">ews_xdefi:hmeobnfnfcmdkdcmlblgagmfpfboieaf;XDEFI;IndexedDB</span><br><span class="line">ews_waveskeeper:lpilbniiabackdjcionkobglmddfbcjo;WavesKeeper;Local Extension Settings</span><br><span class="line">ews_solflare:bhhhlbepdkbapadjdnnojkbgioiodbic;Solflare;Local Extension Settings</span><br><span class="line">ews_rabby:acmacodkjbdgmoleebolmdjonilkdbch;Rabby;Local Extension Settings</span><br><span class="line">ews_cyano:dkdedlpgdmmkkfjabffeganieamfklkm;CyanoWallet;Local Extension Settings</span><br><span class="line">ews_coinbase:hnfanknocfeofbddgcijnmhnfnkdnaad;Coinbase;IndexedDB</span><br><span class="line">ews_auromina:cnmamaachppnkjgnildpdmkaakejnhae;AuroWallet;Local Extension Settings</span><br><span class="line">ews_khc:hcflpincpppdclinealmandijcmnkbgn;KHC;Local Extension Settings</span><br><span class="line">ews_tezbox:mnfifefkajgofkcjkemidiaecocnkjeh;TezBox;Local Extension Settings</span><br><span class="line">ews_coin98:aeachknmefphepccionboohckonoeemg;Coin98;Local Extension Settings</span><br><span class="line">ews_temple:ookjlbkiijinhpmnjffcofjonbfbgaoc;Temple;Local Extension Settings</span><br><span class="line">ews_iconex:flpiciilemghbmfalicajoolhkkenfel;ICONex;Local Extension Settings</span><br><span class="line">ews_sollet:fhmfendgdocmcbmfikdcogofphimnkno;Sollet;Local Extension Settings</span><br><span class="line">ews_clover:nhnkbkgjikgcigadomkphalanndcapjk;CloverWallet;Local Extension Settings</span><br><span class="line">ews_polymesh:jojhfeoedkpkglbfimdfabpdfjaoolaf;PolymeshWallet;Local Extension Settings</span><br><span class="line">ews_neoline:cphhlgmgameodnhkjdmkpanlelnlohao;NeoLine;Local Extension Settings</span><br><span class="line">ews_keplr:dmkamcknogkgcdfhhbddcghachkejeap;Keplr;Local Extension Settings</span><br><span class="line">ews_terra_e:ajkhoeiiokighlmdnlakpjfoobnjinie;TerraStation;Local Extension Settings</span><br><span class="line">ews_terra:aiifbnbfobpmeekipheeijimdpnlpgpp;TerraStation;Local Extension Settings</span><br><span class="line">ews_liquality:kpfopkelmapcoipemfendmdcghnegimn;Liquality;Local Extension Settings</span><br><span class="line">ews_saturn:nkddgncdjgjfcddamfgcmfnlhccnimig;SaturnWallet;Local Extension Settings</span><br><span class="line">ews_guild:nanjmdknhkinifnkgdcggcfnhdaammmj;GuildWallet;Local Extension Settings</span><br><span class="line">ews_phantom:bfnaelmomeimhlpmgjnjophhpkkoljpa;Phantom;Local Extension Settings</span><br><span class="line">ews_tronlink:ibnejdfjmmkpcnlpebklmnkoeoihofec;TronLink;Local Extension Settings</span><br><span class="line">ews_brave:odbfpeeihdkbihmopkbjmoonfanlbfcl;Brave;Local Extension Settings</span><br><span class="line">ews_meta_e:ejbalbakoplchlghecdalmeeeajnimhm;MetaMask;Local Extension Settings</span><br><span class="line">ews_ronin_e:kjmoohlgokccodicjjfebfomlbljgfhk;Ronin;Local Extension Settings</span><br><span class="line">ews_mewcx:nlbmnnijcnlegkjjpcfjclmcfggfefdm;MEW_CX;Sync Extension Settings</span><br><span class="line">ews_ton:cgeeodpfagjceefieflmdfphplkenlfk;TON;Local Extension Settings</span><br><span class="line">ews_goby:jnkelfanjkeadonecabehalmbgpfodjm;Goby;Local Extension Settings</span><br><span class="line">ews_ton_ex:nphplpgoakhhjchkkhmiggakijnkhfnd;TON;Local Extension Settings</span><br><span class="line">ews_Cosmostation:fpkhgmpbidmiogeglndfbkegfdlnajnf;Cosmostation;Local Extension Settings</span><br><span class="line">ews_bitkeep:jiidiaalihmmhddjgbnbgdfflelocpak;BitKeep;Local Extension Settings</span><br><span class="line">ews_stargazer:pgiaagfkgcbnmiiolekcfmljdagdhlcm;Stargazer;Local Extension Settings</span><br><span class="line">ews_clv:nhnkbkgjikgcigadomkphalanndcapjk;CloverWallet;Local Extension Settings</span><br><span class="line">ews_jaxxlibertyext:cjelfplplebdjjenllpjcblmjkfcffne;JaxxLibertyExtension;Local Extension Settings</span><br><span class="line">ews_enkrypt:kkpllkodjeloidieedojogacfhpaihoh;Enkrypt;Local Extension Settings</span><br><span class="line">ews_gamestop:pkkjjapmlcncipeecdmlhaipahfdphkd;GameStop Wallet;Local Extension Settings</span><br><span class="line">ews_xds:aholpfdialjgjfhomihkjbmgjidlcdno;Exodus Web3 Wallet;Local Extension Settings</span><br><span class="line">xtntns_authenticatorcc:bhghoamapcdpbohphigoooaddinpkbai;Authenticator.cc;Sync Extension Settings</span><br><span class="line">xtntns_keepassxc_browser:oboonakemofpalcgghocfoadofidjkkk;KeePassXC Browser;Local Extension Settings</span><br><span class="line">xtntns_keepassTusk:fmhmiaejopepamlcjkncpgpdjichnecm;KeePass Tusk;Local Extension Settings</span><br><span class="line">xtntns_bitwardenEx:nngceckbapebfimnlniiiahkandclblb;Bitwarden;Local Extension Settings</span><br><span class="line">xtntns_microsoftAfL:fiedbfgcleddlbcmgdigjgdfcggjcion;Microsoft Autofill Local;Local Extension Settings</span><br><span class="line">xtntns_microsoftAfS:fiedbfgcleddlbcmgdigjgdfcggjcion;Microsoft Autofill Sync;Sync Extension Settings</span><br><span class="line">grbr_Desktop:%USERPROFILE%\Desktop\|*.txt|*recycle*,*windows*|25|1|1|files</span><br><span class="line">grbr_Documets:%USERPROFILE%\Documents\|*.txt|*recycle*,*windows*|25|1|1|files</span><br><span class="line">ldr_1:hxxp://172[.]86[.]75[.]189/36141266339446703039[.]bin|%APPDATA%\|exe</span><br><span class="line">token:3f9bef70525fd0873fc9acf8b6babce9</span><br></pre></td></tr></table></figure>

<p>从C2下载sqlite3.dll，流量中可以看到下载的PE文件<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/yYXqPTP4VTg47oFW3F7CNIuSMviSumK2/2022091616.jpg"><br>从c2获取的7个dll中，freebl3.dll,mozglue.dll,softokn3.dll,nss3.dll有Mozilla有效签名，msvcp140.dll,vcruntime140.dll有Microsoft有效签名，其中sqlite3.dll为MinGW编译无数字签名<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/NsAz8povfgugw1fcg8ETCyy8fc18Lv8z/2022091617.jpg"><br>3个连续的POST请求使用的User-Agent为<code>rqwrwqrqwrqw</code>，向C2发送了大量明文数据，我们可以看到其中第一个POST请求发送收集到的系统数据System Info.txt，主要内容为本机的操作系统版本和基本硬件信息还有本机安装的软件<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/v8iLID7NaHe2g0URpoe16LSTz4duI1CN/2022091618.jpg"><br>第二个POST请求可以看到发送的是cookies.txt和passwords.txt，收集到的数据是chrome浏览器登陆的账号密码数据和cookies<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Pu5I5u4cnVeRhU7YVfsCkOAUmKgOrTjd/2022091619.jpg"><br>第三个POST请求发送的是passwords.txt，主要就是本机Firefox浏览器保存的登陆网站对应的账号密码<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/AooBTqcJWWjsUlt7o2FPxDplEFdWnu5B/2022091620.jpg"><br>我们查看最后一个GET请求发现36141266339446703039.bin为一个PE文件<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/pgO6zwfKvezbLtC4sAr02JNQUdaoJWzr/2022091621.jpg"><br>我们使用DIE工具查看发现此PE文件为使用Visual Studio 2019编译的并使用ENIGMA5.x版本加壳的32位程序<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/VEg8BrYlMIfr9d2kNunLfD6CHukM54my/2022091622.jpg"><br>通过沙箱分析36141266339446703039.bin有创建计划任务进行持久化的操作<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/tn9rC1mXUlap4h96993OvQWQbz3kBYu9/2022091623.jpg"><br>我们查看部分XMl文件内容，计划任务每隔5分钟会运行XML中的prevhost.exe，根据公开的威胁情报显示此程序功能为剪贴板劫持<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/9VLOk8xImfLtFt3XX5Jl5WYkkepGheE9/2022091624.jpg"><br>查询94[.]131[.]106[.]116的威胁情报发现有2个恶意样本使用了此IP进行通信<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/WnmXhTU6KITyiKqkeEAnlgqOrc3sNB8f/2022091625.jpg"><br>查询172[.]86[.]75[.]189的威胁情报，发现了多个下载样本也是加了Enigma壳<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/OmcP5MOwSpsDD4aLUoBefQcxJdx1y96z/2022091626.jpg"></p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>由于样本都是加了强壳对代码进行VM，于是这里我寻找到了未加壳的样本进行分析，可以看到编译的连接器版本也是14.29，而且此样本是使用纯汇编编写所以样本大小只有55.5KB<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/dGGAvTMRXqMic9YIVk0EhKFVjWlitAuY/2022091627.jpg"><br>首先分析第一个函数，主要通过LoadLibraryW和GetProcAddress函数组合动态获取函数地址<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/QxR3LeL9M7v52K51mI1FUFzf8o3Nmzz9/2022091628.jpg"><br>获取注册表和网络还有字符串加解密相关函数地址<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/ruOCCbJtRcuhr8bfAGQXzn7SpVANIJ8e/2022091629.jpg"><br>字符串使用了Base64编码加RC4加密方式，RC4密钥为<code>edinayarossiya</code><br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/nsN2unkJOvwwlaM6zIfkeFy5vGlbeTkT/2022091630.jpg"><br>我们使用CyberChef随意解密一个字符串可以看到是一个格式化字符串<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/fX7sBeV5O9E0yC8O4isx5XaUWX5QnwT6/2022091631.jpg"><br>字符串解密完成会将一部分字符串转为宽字符<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/nhxvYrWGES4KNFR1VEbtcCaHjgTAs26e/2022091632.jpg"><br>接着又解密了加密字符串，此处RC4使用的密钥为<code>59c9737264c0b3209d9193b8ded6c127</code><br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/VGVGKJvynx5WejuCSWr75MhvwEN3R25u/2022091633.jpg"></p>
<p>使用CyberChef解密字符串，可以看到此字符串为C2的URL<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/6aoBbx3E1jfQm4Pt2K2DMFQ4zKObE5UO/2022091634.jpg"></p>
<p>接着使用GetUserDefaultLocaleName函数获取用户默认语言环境<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/NHQsfCmUHEQbiFwCABPulxIP2Fetf4M4/2022091635.jpg"></p>
<p>StrStrIW函数对比当前默认语言环境是否为ru<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/UCEWQIzqQyDBrFPFvwBqeHXmvpzrEpW9/2022091636.jpg"></p>
<p>使用OpenMutexW打开互斥体<code>8724643052</code><br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/YP41vRi58m1cRG5BVGFmsFmch1yVB6RD/2022091637.jpg"></p>
<p>如果存在互斥体则退出进程，不存在则创建互斥体<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/gortGUPz6vHNeXESXszb1jWO22yxHiND/2022091638.jpg"></p>
<p>接着获取进程的运行权限是否为S-1-5-18（SECURITY_LOCAL_SYSTEM_RID）<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/XRLeoXnFo8pouV0heqOUgpT4QcSbhkHk/2022091639.jpg"></p>
<p>通过获取注册表<code>SOFTWARE\\Microsoft\\Cryptography</code>的MachineGuid作为被感染主机的唯一ID<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Ymim9WCqoAFgYonWa6yBP4R554YowIEJ/2022091640.jpg"><br>获取MachineGuid<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/wiwVY8dhYnP8DNY5TRflmFOigfjBMg3u/2022091641.jpg"><br>接着获取了本机用户名<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/j79JxTkdfnqmgzyaVqAHMENyA9VvqcIX/2022091642.jpg"><br>收集完数据拼接字符串，拼接成的格式为：<code>machineId=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx|username&amp;configId=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</code>其中的configId为第二次解密字符串使用的32位RC4密钥<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Xbw2ijOxmg12Uc01Aq7lIg4iR9KLqK3W/2022091643.jpg"><br>然后发送第一次POST请求，如C2存活会返回明文的配置文件，配置文件中包含了要窃取的指定数据<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/lVJlGQCvF7rMRn6TLJdTaoa6LoTYaSFj/2022091644.jpg"><br>解析配置信息的libs字段从C2下载dll<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/s9EQsST8GkVhxjhb6s90fMowLsualdwI/2022091645.jpg"><br>发送get请求下载dll并使用WriteFile函数保存到本地<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/vjN1ufdiYdBL4cngGabEqTN6KJCcEkFU/2022091646.jpg"><br>收集基本系统信息并格式化发送POST请求到C2<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/PcpalMVVavjqvKKwn2MuGfQCDsn7UczX/2022091647.jpg"><br>接下来的主要逻辑就是解析配置文件，根据配置文件窃取对应的数据并发送到C2<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/IxSueMz19SD9Dixo4LMy6wljW7afz6Ts/2022091648.jpg"><br>我们查看Chromium浏览器窃取函数，首先遍历硬盘查找User Data目录，基于Chromium开发的浏览器默认的数据保存目录一般都在User Data目录下，比如说chrome浏览器的数据存储在<code>C:\Users\username\AppData\Local\Google\Chrome\User Data</code>，如果存在User Data目录则解密相关数据库并使用sqlite3的sql语句查询数据<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/sKtVQe1BcUP4lqIBeIxpVETOJlONFEfw/2022091649.jpg"><br>从Local State文件读取encrypted_key字段用于解密登录密码，后续解密数据并使用sqlite3语句查询数据<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/y601UkfIn1IxhsHCTWXvdgrnrGFASOCD/2022091650.jpg"><br>Login Data是用于保存Chromium浏览器登录账号密码信息的sqlite3数据库，sqlite3查询chrome浏览器登录密码<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Nh7NgqwfL6UX9lQA0cp1hHTrFWAtDKRL/2022091651.jpg"><br>Chromium浏览器的密码加密方式，版本号80之前的可直接使用CryptUnprotectData函数解密，如果80之后的版本密码会有v10开头的标志，解密需要使用Local State文件的中的encrypted_key字段的Aes密钥进行解密<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/fnLj1BROypakKRIhUsS9Ww5hknC3TyGv/2022091652.jpg"><br>打开Network文件夹Cookies数据库文件使用sqlite3 sql语句查询Chromium浏览器cookies<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/y8LLFxLcmxW2HYpY0m4EzEdxLo5hJMwY/2022091653.jpg"><br>sqlite3 sql语句查询Chromium浏览器autofill数据（自动填充账号密码）<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/WPef5BICDlWath3Cihe73QdUd2yAfHDD/2022091654.jpg"><br>打开Web Data数据库文件并使用sqlite3 sql语句查询Chromium浏览器信用卡信息和付款凭证<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/0G9In0EiBOIBPVVEDyjidoYAVD6ndK1k/2022091655.jpg"><br>解析配置文件ews_字段窃取指定浏览器插件的数据，<code>ews_meta_e:ejbalbakoplchlghecdalmeeeajnimhm;MetaMask;Local Extension Settings</code><br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/028UAh6QW7mn5ooAUmvoa4mjr3imex98/2022091656.jpg"><br>遍历硬盘窃取配置文件中指定浏览器插件的数据<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/QopkwqT8QWqLVL9Kkg1HsloHiEBPomnt/2022091657.jpg"><br>获取需要用到的nss3.dll和sqlite3.dll导出函数地址<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/HRhRQeXqkSdr5eSVs23cxEi1htHCAn4w/2022091658.jpg"><br>针对mozilla firefox浏览器用于保存数据的Profiles文件夹进行数据窃取<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/0r96hoci8Q9vctmoQUV7fCkCvjpluTSk/2022091659.jpg"><br>打开cookies.sqlite数据库文件并使用sqlite3 sql语句查询mozilla firefox浏览器cookies<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/W1PjT7eCGCP3B3qAUDiLlA1bwtcrB7l2/2022091660.jpg"><br>读取logins.json文件并解密获取账号密码<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/fWjGklYGszcGKP8sQtfSYc9iq2RMjisX/2022091661.jpg"><br>打开formhistory.sqlite数据库并使用sqlite3 sql语句查询，此数据库中记录着通过 Firefox 搜索框搜索的历史以及在网站填写过的表单<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/qQAOTLk2F6KrAHDwwAV2KaBre9G3lYpA/2022091662.jpg"><br>遍历搜索查找wallet.dat文件<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/vjwF0sWVr6WC7Ud40BD2uP70gReGrK8K/2022091663.jpg"><br>解析配置文件中的grbr_字段，窃取对应路径下的指定文件，配置文件的内容如下<code>grbr_Desktop:%USERPROFILE%\Desktop|*.txt|*recycle*,*windows*|25|1|1|files</code><br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/FfwBpickIuFWdYJ0G7s4WxoaQKFFy2W7/2022091664.jpg"><br>解析配置文件tlgrm_字段，窃取telegram的指定文件数据<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/Brn9dKlng8CNK6WYYWpFjRzHbHjyFlbN/2022091665.jpg"><br>解析配置文件ldr_字段，下载配置文件的payload到指定目录下并运行配置信息如下所示<code>ldr_1:hxxp://172[.]86[.]75[.]189/36141266339446703039[.]bin|%APPDATA%|exe</code><br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/KHwge7t3y4IvPKHwg9flqC62y8NqoE27/2022091666.jpg"><br>如果存在则从C2下载下一阶段的payload并使用ShellExcuteW运行<br><img src="https://lc-gluttony.s3.amazonaws.com/ItdnDM9zGiJj/YsSxQv9XguVXIVzUsub4J1KwYe4wxMwB/2022091667.jpg"></p>
<p>通过分析未加壳的样本，可以推断出这和现在活跃传播的加壳样本都为RaccoonStealer v2版本并且代码没有太多更改，加壳样本的配置文件中多了xtntns_字段用于窃取密码管理软件的数据，后续的更新可能会增加更多数据的窃取功能并且有可能会增加勒索等功能。 </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>RaccoonStealer v2通过伪装破解软件下载站，针对搜索引擎的SEO关键词优化达到广泛传播实现信息窃取，并且使用了VMProtect、Themida、ENIGMA等强壳进行代码VM等保护，使用附加大量重复字节膨胀PE文件大小防止被上传沙箱分析等等，尽量不要下载使用破解软件请多支持官方正版软件，不然碰到RaccoonStealer v2这种类型的恶意软件得不偿失。</p>
<hr />]]></content>
      <categories>
        <category>样本分析</category>
      </categories>
      <tags>
        <tag>Raccoon Stealer v2</tag>
        <tag>窃密的浣熊</tag>
      </tags>
  </entry>
</search>
